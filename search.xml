<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link href="/2020/01/02/3.Longest_Substring_Without_Repeating_Characters/"/>
      <url>/2020/01/02/3.Longest_Substring_Without_Repeating_Characters/</url>
      
        <content type="html"><![CDATA[<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><p><a href="#question">Question</a><br><a href="#question_zh_hant">中文題目</a><br><a href="#tip">相關說明</a><br><a href="#think1">思路1</a><br><a href="#code1">代碼1</a>  </p><!-- [思路2](#think2)  [代碼2](#code2)   --><p><a name="question"></a></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given a string, find the length of the longest substring without repeating characters..  </p><p><a name="question_zh_hant"></a></p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>給定一個字符串，請你找出其中不含有重複字符的 最長子串 的長度  </p><p>Example1:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>Example2:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p>Example3:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><p><a name="tip"></a></p><h3 id="相關說明"><a href="#相關說明" class="headerlink" title="相關說明"></a>相關說明</h3><p>Sliding Windows 滑動窗口<br>什麼是滑動窗口？<br>其實就是一個隊列,比如例題中的 abcabcbb，進入這個隊列（窗口）為 abc 滿足題目要求，當再進入 a，隊列變成了 abca，這時候不滿足要求。所以，我們要移動這個隊列！<br>如何移動？<br>我們只要把隊列的左邊的元素移出就行了，直到滿足題目要求！  </p><p><a name="think1"></a></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="解題關鍵"><a href="#解題關鍵" class="headerlink" title="解題關鍵:"></a>解題關鍵:</h4><p>使用 set in list 的時間複雜度為 O(1)，如果沒有相同元素的話，使用 set in list 會比 list in list 好。<br>將每個結果存入set()中，使用滑動窗口，剔除與增加元素<br>用max_len紀錄最長的值並返回  </p><h4 id="解題詳解"><a href="#解題詳解" class="headerlink" title="解題詳解:"></a>解題詳解:</h4><p>傳入 s 字串<br>首先判斷 s 字串是否有值，若無就直接返回 0<br>n 用來記錄 s 字串的長度<br>left 用來記錄 s 字串當前起始值的位置(會隨著滑動窗口變動)<br>cur_len 為紀錄當前未重覆字串長度(會隨著滑動窗口變動)<br>max_len 為紀錄最大的未重覆字串長度，也是最後要返回的值<br>lookup 為一個集合 紀錄字串的滑動窗口<br>for 迴圈 s 字串的長度 n<br>每迴圈一次，當前長度增加 1<br>判斷當前字串是否在 lookup 集合當中，若有則進入 while 迴圈，會一直迴圈到 s[i]字串不在 lookup 為止<br>left 為 s 字串當前的起始位置，s[left] 為 s 字串的當前起始值( 也為 lookup 集合儲存的最左側值)<br>進入迴圈代表 當前的 s 字串 for 迴圈到的新值 s[i] 存在於 lookup滑動窗口中<br>而有重複字串就移除 s[left]，從 s 字串的當前起始值開始移除，並滑動字串起始值的位置為 left + 1<br>若移除後該字串仍然存在於 lookup 集合中，再度進入 while 迴圈<br>繼續移除 s[left] (新的當前起始值)，滑動字串起始位置為 left + 1，直到該字串不存在於 lookup 集合中<br>結束 while 迴圈<br>比較 cur_len 與 max_len ，若 cur_len 較大則將該值賦給 max_len<br>將 s[i] 字串存入 lookup 中<br>結束 for 迴圈<br>返回 max_len<br>範例、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  字串 s &#x3D; &quot;abcdcfgh&quot;</span><br><span class="line">  a  b  c  d  c  f  g  h  字串</span><br><span class="line">  1  2  3  4  5  6  7  8  字串位置</span><br><span class="line"></span><br><span class="line">  a              for 迴圈至 a ，cur_len 紀錄當前字串最長值為 1，lookup 存入 a，max_len 最大長度 1</span><br><span class="line">  a  b           for 迴圈至 b ，cur_len 紀錄當前字串最長度為 2，b 不存在於 lookup 中 ，lookup 存入 b，max_len 最大長度 2</span><br><span class="line">  a  b  c        for 迴圈至 c ，cur_len 紀錄當前字串最長度為 3，c 不存在於 lookup 中 ，lookup 存入 c，max_len 最大長度 3</span><br><span class="line">  a  b  c  d     for 迴圈至 d ，cur_len 紀錄當前字串最長度為 4，d 不存在於 lookup 中 ，lookup 存入 d，max_len 最大長度 4</span><br><span class="line">  a  b  c  d  c  for 迴圈至 c ，cur_len 紀錄當前字串最長度為 5，c 已存在於 lookup 中 進入 while迴圈 ，lookup 移除最左側的 a ，left 紀錄 s 字串 的起始位置為 1，cur_len 最大長度 5-1&#x3D;4</span><br><span class="line">  b  c  d  c     c 仍存在於 lookup 中 進入 while迴圈 ，lookup 移除最左側的 b ，left 紀錄 s 字串 的起始位置為 2，cur_len 最大長度 3</span><br><span class="line">  c  d  c        c 仍存在於 lookup 中 進入 while迴圈 ，lookup 移除最左側的 c ，left 紀錄 s 字串 的起始位置為 3，cur_len 長度 2</span><br><span class="line">  d  c  f        for 迴圈至 f ，f 不存在於 lookup 中 ，lookup 存入 f，cur_len 紀錄當前字串最長度為 3</span><br><span class="line">  d  c  f  g     for 迴圈至 g ，g 不存在於 lookup 中 ，lookup 存入 g，cur_len 紀錄當前字串最長度為 4</span><br><span class="line">  d  c  f  g  h  for 迴圈至 h ，h 不存在於 lookup 中 ，lookup 存入 h，cur_len 紀錄當前字串最長度為 5，max_len 最大長度 5</span><br><span class="line"></span><br><span class="line">結束返回：max_len &#x3D; 5</span><br></pre></td></tr></table></figure><h4 id="執行時間"><a href="#執行時間" class="headerlink" title="執行時間"></a>執行時間</h4><p>Runtime: 48 ms, faster than 95.87% of Python3 online submissions for Longest Substring Without Repeating Characters.<br>Memory Usage: 12.6 MB, less than 100.00% of Python3 online submissions for Longest Substring Without Repeating Characters.  </p><p><a name="code1"></a></p><h4 id="代碼1"><a href="#代碼1" class="headerlink" title="代碼1"></a>代碼1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        if not s: return 0</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        cur_len &#x3D; 0</span><br><span class="line">        max_len &#x3D; 0</span><br><span class="line">        lookup &#x3D; set()</span><br><span class="line">        for i in range(n):</span><br><span class="line">            cur_len +&#x3D; 1</span><br><span class="line">            while s[i] in lookup:</span><br><span class="line">                lookup.remove(s[left])</span><br><span class="line">                left +&#x3D; 1</span><br><span class="line">                cur_len -&#x3D; 1</span><br><span class="line">            if cur_len &gt; max_len:</span><br><span class="line">                max_len &#x3D; cur_len</span><br><span class="line">            lookup.add(s[i])</span><br><span class="line">        return max_len</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2019/12/31/2.Add-Two-Numbers/"/>
      <url>/2019/12/31/2.Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h2><p><a href="#question">Question</a><br><a href="#question_zh_hant">中文題目</a><br><a href="#tip">相關說明</a><br><a href="#think1">思路1</a><br><a href="#code1">代碼1</a><br><a href="#think2">思路2</a><br><a href="#code2">代碼2</a>  </p><p><a name="question"></a></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two  numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><a name="question_zh_hant"></a></p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>給出兩個 非空 的鍊錶用來表示兩個非負的整數。其中，它們各自的位數是按照 逆序 的方式存儲的，並且它們的每個節點只能存儲 一位 數字。<br>如果，我們將這兩個數相加起來，則會返回一個新的鏈表來表示它們的和。<br>您可以假設除了數字 0 之外，這兩個數都不會以 0 開頭。<br>範例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><a name="tip"></a></p><h3 id="相關說明"><a href="#相關說明" class="headerlink" title="相關說明"></a>相關說明</h3><p>鏈表是線性表(linear list)的一種。線性表是最基本、最簡單、也是最常用的一種資料結構。線性表中數據元素之間的關係是一對一的關系，即除了第一個和最後一個數據元素之外，其它數據元素都是首尾相接的。<br>鏈式儲存結構就是兩個相鄰的元素在記憶體中可能不是物理相鄰的，每一個元素都有一個指標，指標一般是儲存著到下一個元素的指標。<br>這種儲存方式的優點是已知插入位置時，定點插入和定點刪除的時間複雜度為 O(1)，不會浪費太多記憶體，添加元素的時候才會申請記憶體空間，刪除元素會釋放記憶體空間。缺點是訪問的時間複雜度最壞為 O(n)  </p><p><a name="think1"></a></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="解題詳解"><a href="#解題詳解" class="headerlink" title="解題詳解:"></a>解題詳解:</h4><p>判斷input是否存在，轉為列表進行反轉<br>轉為字串後相加，再進行反轉<br>最後將結果轉為鏈表  </p><h4 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h4><p> 時間複雜度 O(N)<br> 空間複雜度 O(N)  </p><p>Runtime: 800 ms, faster than 30.56% of Python3 online submissions for Two Sum.<br>Memory Usage: 13.7 MB, less than 88.37% of Python3 online submissions for Two Sum.  </p><p><a name="code1"></a></p><h4 id="代碼1"><a href="#代碼1" class="headerlink" title="代碼1"></a>代碼1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        l1_list, l2_list &#x3D; [l1.val], [l2.val]</span><br><span class="line">        while l1.next:</span><br><span class="line">            l1_list.append(l1.next.val)</span><br><span class="line">            l1 &#x3D; l1.next</span><br><span class="line">        while l2.next:</span><br><span class="line">            l2_list.append(l2.next.val)</span><br><span class="line">            l2 &#x3D; l2.next</span><br><span class="line">        num1 &#x3D; &#39;&#39;.join([str(i) for i in l1_list[::-1]])</span><br><span class="line">        num2 &#x3D; &#39;&#39;.join([str(i) for i in l2_list[::-1]])</span><br><span class="line">        ans &#x3D; str(int(num1) + int(num2))[::-1]</span><br><span class="line">        res &#x3D; ListNode(int(ans[0]))</span><br><span class="line">        run_res &#x3D; res</span><br><span class="line">        for i in range(1, len(ans)):</span><br><span class="line">            run_res.next &#x3D; ListNode(int(ans[i]))</span><br><span class="line">            run_res &#x3D; run_res.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><a name="think2"></a></p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><h4 id="解題關鍵"><a href="#解題關鍵" class="headerlink" title="解題關鍵:"></a>解題關鍵:</h4><p>主要會設置以下幾個變數<br>carry 進位點<br>curr = ListNode(0) 新鏈表<br>pre = curr 預先指針 (頭節點為 pre.next)，由於 curr 返回節點3的時候，沒有引用的1、2節點會被回收，因此使用pre並且不引用來返回最終結果<br>val 為每次迴圈 l1、l2 值的相加  </p><p>※概略圖、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">carry(0) 7-&gt;8-&gt;9  </span><br><span class="line">         3-&gt;2</span><br><span class="line">pre(0)</span><br></pre></td></tr></table></figure><h4 id="解題詳解-1"><a href="#解題詳解-1" class="headerlink" title="解題詳解:"></a>解題詳解:</h4><p>設置進位點 carry = 0<br>新鏈表 curr，並用 pre 儲存節點<br>迴圈 判斷輸入值 l1 或 l2 是否存在<br>val 加入 l1.val 和 l2.val<br>並將 l1 與 l2 進入到下一個節點 l1.next 與 l2.next<br>相加後的 val 需確認是否有進位，因此除以10<br>將餘數轉換為ListNode類型，加入至新鏈表 curr 的新節點 curr.next<br>商數則存入 carry  </p><p>迴圈至 l1 和 l2 皆沒有下一個節點後<br>先判斷是否有進位，若有則轉換為ListNode類型，加入至新鏈表 curr 的新節點 curr.next<br>由於 curr 被引用後，前面的節點會被會回收，因此要使用一開始儲存好沒有被引用過的 pre<br>一開始儲存的初始節點 pre 為 ListNode(0)<br>返回 pre 的下一個節點 pre.next(頭節點) 就是最終的答案</p><h4 id="執行時間"><a href="#執行時間" class="headerlink" title="執行時間"></a>執行時間</h4><p>Runtime: 64 ms, faster than 89.40% of Python3 online submissions for Add Two Numbers.<br>Memory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Add Two Numbers.</p><p><a name="code2"></a></p><h4 id="代碼2"><a href="#代碼2" class="headerlink" title="代碼2"></a>代碼2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        carry &#x3D; 0</span><br><span class="line">        curr &#x3D;  ListNode(0)</span><br><span class="line">        pre &#x3D; curr</span><br><span class="line">        while l1 or l2:</span><br><span class="line">            val &#x3D; carry</span><br><span class="line">            if l1:</span><br><span class="line">                val +&#x3D; l1.val</span><br><span class="line">                l1 &#x3D; l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                val +&#x3D; l2.val</span><br><span class="line">                l2 &#x3D; l2.next</span><br><span class="line">            curr.next &#x3D; ListNode(val % 10)</span><br><span class="line">            curr &#x3D; curr.next</span><br><span class="line">            carry &#x3D; val&#x2F;&#x2F;10</span><br><span class="line">            </span><br><span class="line">        if carry &gt; 0:</span><br><span class="line">            curr.next &#x3D; ListNode(carry)</span><br><span class="line">            </span><br><span class="line">        return pre.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2019/12/29/1.-Two-Sum/"/>
      <url>/2019/12/29/1.-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p><a href="#question">Question</a><br><a href="#question_zh_hant">中文題目</a><br><a href="#answer1">解法</a><br><a href="#think1">思路</a><br><a href="#bigo">Big-O</a><br><a href="#code">代碼</a>  </p><p><a name="question"></a></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:  </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p><a name="question_zh_hant"></a></p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>給定一個整數數組 nums 和一個目標值 target，請你在該數組中找出和為目標值的那 兩個 整數，並返回他們的數組下標。<br>你可以假設每種輸入只會對應一個答案。但是，你不能重複利用這個數組中同樣的元素。<br>範例:  </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p><a name="answer1"></a></p><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>這裡會使用到以下兩個方法:<br>list.count()<br>list.index()<br>count() 方法用於統計某個元素在列表中出現的次數。<br>count()方法語法：  </p><pre><code>list.count(obj)</code></pre><p>index() 函數用於從列表中找出某個值第一個匹配項的索引位置。<br>index()方法語法：  </p><pre><code>list . index ( x [, start [, end ]])  </code></pre><p><a name="think1"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解題關鍵:<br>主要是想找到num2 = target - num1，是否也在list中，那麼就需要運用以下兩個方法：<br>num2 in nums，返回True<br>nums.index(num2)，查找num2的索引  </p><p>解題詳解:<br>首先計算 nums 的長度並存入變數<br>宣告變數 j 為 -1，在最後若沒找到 num2 可用 j 是否大於0進行判斷<br>使用 for 迴圈進行遍歷<br>使用 if 判斷 num2 in nums  ，對 list 使用 in 的時間複雜度為 O(n)<br>如果 num2 = num1 ，且 nums 中只出現了一次，說明找到是 num1 本身<br>將此情況使用 if 判斷，再使用 continue 跳過<br>如果不是找到 num1 本身，則將該值存入 j<br>index(x,i+1) 是從 num1 的序列後找 num2，避免重複查找<br>判斷 j 是否大於0，大於0代表有找到 num2，將 i，j 值返回<br>若無找到 num2 則返回空值  </p><p><a name="bigo"></a></p><h3 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h3><p> 時間複雜度 O(N^2)<br> 空間複雜度 O(N)  </p><p>Runtime: 800 ms, faster than 30.56% of Python3 online submissions for Two Sum.<br>Memory Usage: 13.7 MB, less than 88.37% of Python3 online submissions for Two Sum.  </p><p><a name="code"></a></p><h3 id="代碼"><a href="#代碼" class="headerlink" title="代碼"></a>代碼</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        lens &#x3D; len(nums)</span><br><span class="line">        j &#x3D; -1</span><br><span class="line">        for i in range(lens):</span><br><span class="line">            if (target-nums[i]) in nums:</span><br><span class="line">                if (nums.count(target-nums[i]) &#x3D;&#x3D; 1) &amp; (target-nums[i] &#x3D;&#x3D; nums[i]):</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    j &#x3D; nums.index(target-nums[i], i+1)</span><br><span class="line">                    break</span><br><span class="line">        if j &gt; 0:</span><br><span class="line">            return [i,j]</span><br><span class="line">        else:</span><br><span class="line">            return []</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
