<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2019/12/31/2.Add-Two-Numbers/"/>
      <url>/2019/12/31/2.Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h2><p><a href="#question">Question</a><br><a href="#question_zh_hant">中文題目</a><br><a href="#tip">相關說明</a><br><a href="#think1">思路1</a><br><a href="#code1">代碼1</a><br><a href="#think2">思路2</a><br><a href="#code2">代碼2</a>  </p><p><a name="question"></a></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two  numbers and return it as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.<br>Example:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><a name="question_zh_hant"></a></p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>給出兩個 非空 的鍊錶用來表示兩個非負的整數。其中，它們各自的位數是按照 逆序 的方式存儲的，並且它們的每個節點只能存儲 一位 數字。<br>如果，我們將這兩個數相加起來，則會返回一個新的鏈表來表示它們的和。<br>您可以假設除了數字 0 之外，這兩個數都不會以 0 開頭。<br>範例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p><a name="tip"></a></p><h3 id="相關說明"><a href="#相關說明" class="headerlink" title="相關說明"></a>相關說明</h3><p>鏈表是線性表(linear list)的一種。線性表是最基本、最簡單、也是最常用的一種資料結構。線性表中數據元素之間的關係是一對一的關系，即除了第一個和最後一個數據元素之外，其它數據元素都是首尾相接的。<br>鏈式儲存結構就是兩個相鄰的元素在記憶體中可能不是物理相鄰的，每一個元素都有一個指標，指標一般是儲存著到下一個元素的指標。<br>這種儲存方式的優點是已知插入位置時，定點插入和定點刪除的時間複雜度為 O(1)，不會浪費太多記憶體，添加元素的時候才會申請記憶體空間，刪除元素會釋放記憶體空間。缺點是訪問的時間複雜度最壞為 O(n)  </p><p><a name="think1"></a></p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="解題詳解"><a href="#解題詳解" class="headerlink" title="解題詳解:"></a>解題詳解:</h4><p>判斷input是否存在，轉為列表進行反轉<br>轉為字串後相加，再進行反轉<br>最後將結果轉為鏈表  </p><h4 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h4><p> 時間複雜度 O(N)<br> 空間複雜度 O(N)  </p><p>Runtime: 800 ms, faster than 30.56% of Python3 online submissions for Two Sum.<br>Memory Usage: 13.7 MB, less than 88.37% of Python3 online submissions for Two Sum.  </p><p><a name="code1"></a></p><h4 id="代碼1"><a href="#代碼1" class="headerlink" title="代碼1"></a>代碼1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        l1_list, l2_list &#x3D; [l1.val], [l2.val]</span><br><span class="line">        while l1.next:</span><br><span class="line">            l1_list.append(l1.next.val)</span><br><span class="line">            l1 &#x3D; l1.next</span><br><span class="line">        while l2.next:</span><br><span class="line">            l2_list.append(l2.next.val)</span><br><span class="line">            l2 &#x3D; l2.next</span><br><span class="line">        num1 &#x3D; &#39;&#39;.join([str(i) for i in l1_list[::-1]])</span><br><span class="line">        num2 &#x3D; &#39;&#39;.join([str(i) for i in l2_list[::-1]])</span><br><span class="line">        ans &#x3D; str(int(num1) + int(num2))[::-1]</span><br><span class="line">        res &#x3D; ListNode(int(ans[0]))</span><br><span class="line">        run_res &#x3D; res</span><br><span class="line">        for i in range(1, len(ans)):</span><br><span class="line">            run_res.next &#x3D; ListNode(int(ans[i]))</span><br><span class="line">            run_res &#x3D; run_res.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p><a name="think2"></a></p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><h4 id="解題關鍵"><a href="#解題關鍵" class="headerlink" title="解題關鍵:"></a>解題關鍵:</h4><p>主要會設置以下幾個變數<br>carry 進位點<br>curr = ListNode(0) 新鏈表<br>pre = curr 預先指針 (頭節點為 pre.next)，由於 curr 返回節點3的時候，沒有引用的1、2節點會被回收，因此使用pre並且不引用來返回最終結果<br>val 為每次迴圈 l1、l2 值的相加  </p><p>※概略圖、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">carry(0) 7-&gt;8-&gt;9  </span><br><span class="line">         3-&gt;2</span><br><span class="line">pre(0)</span><br></pre></td></tr></table></figure><h4 id="解題詳解-1"><a href="#解題詳解-1" class="headerlink" title="解題詳解:"></a>解題詳解:</h4><p>設置進位點 carry = 0<br>新鏈表 curr，並用 pre 儲存節點<br>迴圈 判斷輸入值 l1 或 l2 是否存在<br>val 加入 l1.val 和 l2.val<br>並將 l1 與 l2 進入到下一個節點 l1.next 與 l2.next<br>相加後的 val 需確認是否有進位，因此除以10<br>將餘數轉換為ListNode類型，加入至新鏈表 curr 的新節點 curr.next<br>商數則存入 carry  </p><p>迴圈至 l1 和 l2 皆沒有下一個節點後<br>先判斷是否有進位，若有則轉換為ListNode類型，加入至新鏈表 curr 的新節點 curr.next<br>由於 curr 被引用後，前面的節點會被會回收，因此要使用一開始儲存好沒有被引用過的 pre<br>一開始儲存的初始節點 pre 為 ListNode(0)<br>返回 pre 的下一個節點 pre.next(頭節點) 就是最終的答案</p><h4 id="執行時間"><a href="#執行時間" class="headerlink" title="執行時間"></a>執行時間</h4><p>Runtime: 64 ms, faster than 89.40% of Python3 online submissions for Add Two Numbers.<br>Memory Usage: 12.8 MB, less than 100.00% of Python3 online submissions for Add Two Numbers.</p><p><a name="code2"></a></p><h4 id="代碼2"><a href="#代碼2" class="headerlink" title="代碼2"></a>代碼2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        carry &#x3D; 0</span><br><span class="line">        curr &#x3D;  ListNode(0)</span><br><span class="line">        pre &#x3D; curr</span><br><span class="line">        while l1 or l2:</span><br><span class="line">            val &#x3D; carry</span><br><span class="line">            if l1:</span><br><span class="line">                val +&#x3D; l1.val</span><br><span class="line">                l1 &#x3D; l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                val +&#x3D; l2.val</span><br><span class="line">                l2 &#x3D; l2.next</span><br><span class="line">            curr.next &#x3D; ListNode(val % 10)</span><br><span class="line">            curr &#x3D; curr.next</span><br><span class="line">            carry &#x3D; val&#x2F;&#x2F;10</span><br><span class="line">            </span><br><span class="line">        if carry &gt; 0:</span><br><span class="line">            curr.next &#x3D; ListNode(carry)</span><br><span class="line">            </span><br><span class="line">        return pre.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2019/12/29/1.-Two-Sum/"/>
      <url>/2019/12/29/1.-Two-Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p><a href="#question">Question</a><br><a href="#question_zh_hant">中文題目</a><br><a href="#answer1">解法</a><br><a href="#think1">思路</a><br><a href="#bigo">Big-O</a><br><a href="#code">代碼</a>  </p><p><a name="question"></a></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.<br>Example:  </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p><a name="question_zh_hant"></a></p><h3 id="題目"><a href="#題目" class="headerlink" title="題目"></a>題目</h3><p>給定一個整數數組 nums 和一個目標值 target，請你在該數組中找出和為目標值的那 兩個 整數，並返回他們的數組下標。<br>你可以假設每種輸入只會對應一個答案。但是，你不能重複利用這個數組中同樣的元素。<br>範例:  </p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p><a name="answer1"></a></p><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>這裡會使用到以下兩個方法:<br>list.count()<br>list.index()<br>count() 方法用於統計某個元素在列表中出現的次數。<br>count()方法語法：  </p><pre><code>list.count(obj)</code></pre><p>index() 函數用於從列表中找出某個值第一個匹配項的索引位置。<br>index()方法語法：  </p><pre><code>list . index ( x [, start [, end ]])  </code></pre><p><a name="think1"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>解題關鍵:<br>主要是想找到num2 = target - num1，是否也在list中，那麼就需要運用以下兩個方法：<br>num2 in nums，返回True<br>nums.index(num2)，查找num2的索引  </p><p>解題詳解:<br>首先計算 nums 的長度並存入變數<br>宣告變數 j 為 -1，在最後若沒找到 num2 可用 j 是否大於0進行判斷<br>使用 for 迴圈進行遍歷<br>使用 if 判斷 num2 in nums  ，對 list 使用 in 的時間複雜度為 O(n)<br>如果 num2 = num1 ，且 nums 中只出現了一次，說明找到是 num1 本身<br>將此情況使用 if 判斷，再使用 continue 跳過<br>如果不是找到 num1 本身，則將該值存入 j<br>index(x,i+1) 是從 num1 的序列後找 num2，避免重複查找<br>判斷 j 是否大於0，大於0代表有找到 num2，將 i，j 值返回<br>若無找到 num2 則返回空值  </p><p><a name="bigo"></a></p><h3 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h3><p> 時間複雜度 O(N^2)<br> 空間複雜度 O(N)  </p><p>Runtime: 800 ms, faster than 30.56% of Python3 online submissions for Two Sum.<br>Memory Usage: 13.7 MB, less than 88.37% of Python3 online submissions for Two Sum.  </p><p><a name="code"></a></p><h3 id="代碼"><a href="#代碼" class="headerlink" title="代碼"></a>代碼</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        lens &#x3D; len(nums)</span><br><span class="line">        j &#x3D; -1</span><br><span class="line">        for i in range(lens):</span><br><span class="line">            if (target-nums[i]) in nums:</span><br><span class="line">                if (nums.count(target-nums[i]) &#x3D;&#x3D; 1) &amp; (target-nums[i] &#x3D;&#x3D; nums[i]):</span><br><span class="line">                    continue</span><br><span class="line">                else:</span><br><span class="line">                    j &#x3D; nums.index(target-nums[i], i+1)</span><br><span class="line">                    break</span><br><span class="line">        if j &gt; 0:</span><br><span class="line">            return [i,j]</span><br><span class="line">        else:</span><br><span class="line">            return []</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
